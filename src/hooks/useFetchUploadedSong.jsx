import axios from "axios";
import { useContext, useCallback } from "react";
import { SongsContext } from "../context/SongsContext";
import { useImmer } from "use-immer";
import songsData from "../data/songsData";

export default function useFetchUploadedSong(file) {
  let [num, setNum] = useImmer(songsData.length);
  const [msg, setMsg] = useImmer(null);
  const [progress, setProgress] = useImmer({ started: false, pc: 0 });
  const { setSongs, setFilteredSongs, setControlFilters } = useContext(SongsContext);

    /**
     * * If the file chose(true) will be created FormData object
     * * which will contain the current selected file - see the line(27-32)
     * * then will happen API post request to testing(can be changed to a real one) server - see the line(38)
     * * result will be pushed to state of the songs list - see the line(45)
     * * name and author too but it will be taken from passed file(files event) - see the line(48, 49)
     * * track number generated by incrementing single variable - see the line(43)
     * * also it will handle progress bar relying on AXIOS method - see the line(40)
     * @param {Object} file - File data from input{file} 
     * @returns {Object} asyncFetchData, msg, progress - asyncFetchData it will be called(in MusicUploadForm component)
     * * for getting uploaded song after click(in function handleUpload) 
     * * msg and progress status(msg) about the process and progress for the progress bar
     */
     const asyncFetchData = useCallback(async () => {
            if (!file) {
              setMsg("No file selected !");
              return
            }
        
            const fd = new FormData();
            fd.append("song", file);
            setMsg("Uploading...");
            setProgress((prev) => {prev.started = true});
            
            try {
              let response = await axios.post("https://httpbin.org/post", fd, {
                onUploadProgress: function (progressEvent) {
                  setProgress((prev) => {prev.pc = progressEvent.progress * 100});
                },
              });
              setNum(++num);
              setSongs((draft) => {
                draft.push({
                  trackNumber: num,
                  src: response.data.files.song, // * song path 
                  songName: file.name.substring(0, 15),
                  artistName: file.name.substring(0, 10),
                });
              });
              setMsg("Upload successful");
            } catch (error) {
              setMsg("Upload failed");
            } finally {
              setFilteredSongs(false) // * Reset the filtered songs to initial state
              setControlFilters({select: '', search: ''}) // * Reset filters to initial state
              setProgress((prev) => {prev.started = false});
            }
    }, [file])

    return { asyncFetchData, msg, progress };
  }